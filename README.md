# 极客时间 Java进阶训练营 毕业总结

分别用 100 个字以上的一段话，加上一幅图（架构图或脑图），总结自己对下列技术的关键点思考和经验认识。

[TOC]

## 一、JVM

JVM是Java Virtual Machine（Java虚拟机）的缩写，Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

JVM包括类加载器子系统、运行时数据区、执行引擎和本地接口库，其中运行时数据区如下图所示：

![image-20220222114428280](https://raw.githubusercontent.com/LiBaoshe/images/master/imgs/image-20220222114428280.png)

在训练营中学习了以下知识点：

**字节码技术**，字节码指令Java bytecode由单字节（byte）的指令组成，理论上最多支持256个操作码（opcode）,实际上Java只使用了200左右的操作码，还有一些操作码则保留给调试操作。根据指令的性质，主要分为四个大类：1.栈操作指令，2.程序流程控制指令，3.对象操作指令，4.算术运算以及类型转换指令。

**类加载器**（启动类加载器、扩展类加载器、应用类加载器、自定义类加载器），加载器特点：双亲委托、负责依赖、缓存加载。类的生命周期：加载（class文件）、验证（格式、依赖）、准备（静态变量初始值、方发表）、解析（常量池内的符号引用替换为直接引用）、初始化（构造器、静态变量赋值、静态代码块）、使用、卸载。

**内存模型**，JMM 规范明确定义了不同的线程之间，通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台和操作系统之间的内存
访问差异，实现了 Java 并发程序真正的跨平台。

**启动参数**，以 - 开头为标准参数，-D设置系统属性，-X开头为非标准参数，-XX开头为非稳定参数。

**命令行工具**

| 工具      | 简介                     | 工具           | 简介              |
| --------- | ------------------------ | -------------- | ----------------- |
| jps/jinfo | 查看java进程             | jstat          | 查看JVM内部GC信息 |
| jmap      | 查看heap或类占用空间统计 | jstack         | 查看线程信息      |
| jcmd      | 整合命令                 | jrunscript/jjs | 执行js命令        |

jstat -gcutil pid 1000 1000		jstat -gc pid 1000 1000		

jmap -heap pid 打印堆内存的配置和使用信息

jmap -histo pid 看哪些类占用的空间多，直方图

jmap -dump:fomat=b,file=pid.hprof pid	dump堆内存

jstack -F（强制执行）/ -m（混合模式）/ -l（长列表模式，包含locks信息） pid

jcmd pid VM.version		jcmd pid Thread.print		jcmd GC.heap_info

**图形化工具**，jconsole,  jvisualvm,  VisualGC,  jmc

**GC算法**

确定垃圾算法：

1.引用计数算法，存在循环引用的问题。

2.可达性分析算法，从GC Roots开始搜索对象是否可达，可作为GC Roots的对象包括以下几种：栈中的引用、方法区中的静态引用、JNI中的引用、JVM内部引用（基本数据类型对应的Class对象，常驻异常对象（如NPE，OOM等），系统类加载器）、被同步锁（synchronized）持有的对象等。

垃圾回收算法：

| 算法         | 特点                                                         |
| ------------ | ------------------------------------------------------------ |
| 标记清除算法 | 引起内存碎片化，大对象无法活动连续可用的空间。               |
| 复制算法     | 内存浪费一半，只适合“朝生夕死”的对象回收。                   |
| 标记整理算法 | 结合了标记清除和复制算法的优点，标记完后将存活的对象移到另一端，清除该端。 |
| 分代收集算法 | 针对不同对象类型（生命周期长短、对象大小），采用不同的垃圾回收算法。 |

JVM运行时内存也叫作JVM堆，从GC的角度可以分为新生代（默认占1/3空间），老年代（默认占2/3空间），永久代（元空间，占非常少的空间）。新生代又分为Eden区、SurviorTo区和SurivorFrom区，默认占比 8:1:1。

新生代GC叫做MinorGC，采用复制算法。主要存生命周期短的对象和小对象，新建的对象存放在Eden区，空间不足时触发MinorGC。1）把Eden区和SurvivorFrom区中存活的对象复制到SurvivorTo区，2）清空Eden区和SurvivorFrom区中的对象，3）将SurvivorTo区和SurvivorFrom区互换。

老年代GC叫做MajorGC，采用标记清除/整理算法。主要存生命周期长的对象和大对象，MajorGC之前会进行一次MinorGC，MajorGC耗时较长，老年代没有空间分配时会抛出OOM异常。

永久代指内存的永久保存区域，GC不会在运行期间对永久代的内存进行清理。Java8中改为元空间，元空间并没有使用JVM内存，而是直接使用操作系统的本地内存，类的元数据放入本地内存中，常量池和类的静态变量放入Java堆中。

4种引用类型：强引用（造成内存泄漏），软引用（SoftReference，空间不足时会被回收），弱引用（WeakReference，垃圾回收过程中一定被回收），虚引用（PhantomRefrence，和引用队列联合使用，主要用于跟踪对象的垃圾回收状态）。

**垃圾收集器**

| 收集器            | 模式 | 收集区 | 算法          | 目标         | 适用场景              |
| ----------------- | ---- | ------ | ------------- | ------------ | --------------------- |
| Serial            | 串行 | 新生代 | 复制算法      | 响应速度优先 | 单CPU的client模式     |
| Serial Old        | 串行 | 老年代 | 标记整理      | 响应速度优先 | 单CPU，CMS的备案      |
| ParNew            | 并行 | 新生代 | 复制算法      | 响应速度优先 | 多CPU配合CMS          |
| Parallel Scavenge | 并行 | 新生代 | 复制算法      | 吞吐量优先   | 运算多交互少          |
| Parallel Old      | 并行 | 老年代 | 标记整理      | 吞吐量优先   | 运算多交互少          |
| CMS               | 并发 | 老年代 | 标记清除      | 响应速度优先 | B/S服务端             |
| G1                | 并发 | both   | 标记整理+复制 | 响应速度优先 | 服务端,代替CMS,大内存 |

CMS，Concurrent Mark Sweep，设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
1. 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。
2. 在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。

默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4。

CMS的六个阶段：

1. **初始标记（STW）**，只标记 GC Roots
2. **并发标记**，和用户线程一起工作，执行GC Roots跟踪过程
3. 并发预清理，如果在并发标记过程中引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的 卡片标记（Card Marking）。
4. **重新标记（STW）**，确保并发执行的部分对象的状态正确性
5. **并发清除**，
6. 并发重置。

G1，Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它。G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。-XX:+UseG1GC -XX:MaxGCPauseMillis=50

常用垃圾收集器组合

![image-20220222180340176](https://raw.githubusercontent.com/LiBaoshe/images/master/imgs/image-20220222180340176.png)

（1）Serial + Serial Old，实现单线程的低延迟垃圾回收机制。

（2）ParNew + CMS，实现多线程的低延迟垃圾回收机制。

（3）Parallel Scavenge + Parallel Old，实现多线程的高吞吐量垃圾回收机制。

ZGC，最大停顿时间不超过10ms，支持超大内存（4TB，JDK13升至16TB），当前只支持Linux/x64，JDK15后支持MacOS和Windows系统。

Shenandoah GC 立项比 ZGC 更早，设计为GC 线程与应用线程并发执行的方式，通过实现垃圾回收过程的并发处理，改善停顿时间，使得 GC 执行线程能够在业务处理线程运行过程中进行堆压缩、标记和整理，从而消除了绝大部分的暂停时间。Shenandoah 团队对外宣称 Shenandoah GC 的暂停时间与堆大小无关，无论是 200 MB 还是 200 GB的堆内存，都可以保障具有很低的暂停时间（注意:并不像 ZGC 那样保证暂停时间在 10ms 以内）。

## 二、NIO



## 三、并发编程



## 四、Spring 和 ORM 等框架



## 五、MySQL 数据库和 SQL



## 六、分库分表



## 七、RPC 和微服务



## 八、分布式缓存



## 九、分布式消息队列

